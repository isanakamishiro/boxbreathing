/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package net.isanakamishiro.boxbreathing.presentation.mirai.ui;

import com.google.gwt.core.shared.GWT;
import elemental2.dom.DomGlobal;
import elemental2.dom.HTMLCanvasElement;
import elemental2.dom.HTMLElement;
import io.reactivex.Observable;
import java.util.Arrays;
import lombok.Builder;
import lombok.Getter;
import lombok.experimental.Accessors;
import net.isanakamishiro.boxbreathing.presentation.utils.jsinterop.dom.Window;
import net.isanakamishiro.boxbreathing.presentation.utils.jsinterop.threejs.cameras.PerspectiveCamera;
import net.isanakamishiro.boxbreathing.presentation.utils.jsinterop.threejs.controls.OrbitControls;
import net.isanakamishiro.boxbreathing.presentation.utils.jsinterop.threejs.core.Clock;
import net.isanakamishiro.boxbreathing.presentation.utils.jsinterop.threejs.core.Color;
import net.isanakamishiro.boxbreathing.presentation.utils.jsinterop.threejs.effects.OutlineEffect;
import net.isanakamishiro.boxbreathing.presentation.utils.jsinterop.threejs.helper.MMDHelper;
import net.isanakamishiro.boxbreathing.presentation.utils.jsinterop.threejs.lights.AmbientLight;
import net.isanakamishiro.boxbreathing.presentation.utils.jsinterop.threejs.lights.DirectionalLight;
import net.isanakamishiro.boxbreathing.presentation.utils.jsinterop.threejs.loader.MMDLoader;
import net.isanakamishiro.boxbreathing.presentation.utils.jsinterop.threejs.objects.Mesh;
import net.isanakamishiro.boxbreathing.presentation.utils.jsinterop.threejs.objects.VmdObject;
import net.isanakamishiro.boxbreathing.presentation.utils.jsinterop.threejs.renderers.WebGLRenderer;
import net.isanakamishiro.boxbreathing.presentation.utils.jsinterop.threejs.scenes.Scene;
import net.isanakamishiro.boxbreathing.presentation.utils.jsinterop.threejs.stats.Stats;

/**
 *
 * @author isana
 */
public class MMDStage implements Stage {

    @Getter
    @Accessors(fluent = true)
    public static enum ModelOption {

        CHARACTER(true, true, false),
        FLOOR(false, false, true),
        DOME(false, false, true);

        private final boolean physics;
        private final boolean castShadow;
        private final boolean receiveShadow;

        private ModelOption(boolean physics, boolean castShadow, boolean receiveShadow) {
            this.physics = physics;
            this.castShadow = castShadow;
            this.receiveShadow = receiveShadow;
        }
    }

    private int canvasWidth = 0;
    private int canvasHeight = 0;

    private final MMDLoader loader;

    private PerspectiveCamera camera;
    private OrbitControls controls;
    private WebGLRenderer renderer;
    private OutlineEffect effect;

    // MMD Mesh
    private Mesh mmdCharacter;
    private Mesh mmdFloor;
    private Mesh mmdDome;
    private VmdObject vmdCamera;

    private Scene scene;
    private Stats stats;
    private Clock clock;
    private MMDHelper mmdHelper;
    private Window.AnimationFrameCallback callback;

    private HTMLCanvasElement canvasElement;

    private boolean pause = false;

    public MMDStage(MMDLoader loader) {
        this.loader = loader;

        init();
    }
//
//    private Observable<LoadingProgress<Mesh>> loadModel(String modelFile, ModelOption option) {
//        return Observable.create(e2 -> {
//            MMDLoader.OnProgressCallback onProgress = xhr -> {
//                e2.onNext(LoadingProgress.<Mesh>builder()
//                        .resourceName(modelFile)
//                        .loaded(xhr.loaded)
//                        .total(xhr.total)
//                        .completed(false)
//                        .loadedResource(null)
//                        .build());
//            };
//
//            MMDLoader.OnErrorCallback onError = error -> {
//                e2.onError(new RuntimeException(error.message));
//            };
//
//            getLoader().loadModel(modelFile, obj -> {
//                obj.castShadow = option.castShadow();
//                obj.receiveShadow = option.receiveShadow();
//
//                scene.add(obj);
//                mmdHelper.add(obj);
//
//                if (option.physics()) {
//                    mmdHelper.setPhysics(obj);
//                }
//
//                e2.onNext(LoadingProgress.<Mesh>builder()
//                        .resourceName(modelFile)
//                        .loaded(1)
//                        .total(1)
//                        .completed(true)
//                        .loadedResource(obj)
//                        .build());
//
//                e2.onComplete();
//            }, onProgress, onError);
//        });
//    }

//    private Observable<LoadingProgress<VmdObject>> loadVmds(String[] vmdFiles) {
//        return Observable.create(e2 -> {
//            MMDLoader.OnProgressCallback onProgress = xhr -> {
//                e2.onNext(LoadingProgress.<VmdObject>builder()
//                        .resourceName(Arrays.toString(vmdFiles))
//                        .loaded(xhr.loaded)
//                        .total(xhr.total)
//                        .completed(false)
//                        .loadedResource(null)
//                        .build());
//            };
//
//            MMDLoader.OnErrorCallback onError = error -> {
//                e2.onError(new RuntimeException(error.message));
//            };
//
//            getLoader().loadVmds(vmdFiles, obj -> {
//
//                e2.onNext(LoadingProgress.<VmdObject>builder()
//                        .resourceName(Arrays.toString(vmdFiles))
//                        .loaded(1)
//                        .total(1)
//                        .completed(true)
//                        .loadedResource(obj)
//                        .build());
//
//                e2.onComplete();
//            }, onProgress, onError);
//        });
//    }
    private <T> Progress convertLoadingProgress(LoadingProgress<T> loadingProgress) {
        return Progress.builder()
                .resourceName(loadingProgress.resourceName())
                .loaded(loadingProgress.loaded())
                .total(loadingProgress.total())
                .build();
    }

    @Override
    public Observable<Progress> loadCharacter(String modelFile) {
        return null;
//
//        return Observable.create(s1 -> {
//            GWT.log("start loadCharacter");
//
//            MMDLoader.OnProgressCallback onProgress = xhr -> {
//                s1.onNext(Progress.builder()
//                        .resourceName(modelFile)
//                        .loaded(xhr.loaded)
//                        .total(xhr.total)
//                        .build());
//            };
//
//            MMDLoader.OnErrorCallback onError = error -> {
//                s1.onError(new RuntimeException(error.message));
//            };
//
//            getLoader().loadModel(modelFile, obj -> {
//                mmdCharacter = obj;
////                mmdCharacter.position.y = -10;
//                mmdCharacter.castShadow = true;
//                mmdCharacter.receiveShadow = ModelOption.CHARACTER.receiveShadow();
//
//                scene.add(mmdCharacter);
//
//                mmdHelper.add(mmdCharacter);
//                mmdHelper.setPhysics(mmdCharacter);
//
//                s1.onComplete();
//            }, onProgress, onError);
//        });
    }

    @Override
    public Observable<Progress> loadPose(String[] motionFiles) {
        return null;

//        return Observable.create(lp -> {
//            GWT.log("start loadPose");
//
//            MMDLoader.OnProgressCallback onProgress = xhr -> {
//                lp.onNext(Progress.builder()
//                        .resourceName(Arrays.toString(motionFiles))
//                        .loaded(xhr.loaded)
//                        .total(xhr.total)
//                        .build());
//            };
//
//            MMDLoader.OnErrorCallback onError = error -> {
//                lp.onError(new RuntimeException(error.message));
//            };
//
//            getLoader().loadVmds(motionFiles, obj -> {
//
//                loader.pourVmdIntoModel(mmdCharacter, obj);
//                mmdHelper.setAnimation(mmdCharacter);
//
//                lp.onComplete();
//
//            }, onProgress, onError);
//        });
    }

    @Override
    public Observable<Progress> loadFloor(String stageFile) {
        return null;

//        return Observable.create(ss -> {
//            GWT.log("start loadFloor");
//
//            this.loadModel(stageFile, ModelOption.FLOOR)
//                    .subscribe(v -> {
//                        this.mmdFloor = v.loadedResource();
//                        ss.onNext(convertLoadingProgress(v));
//                    },
//                            ss::onError, ss::onComplete);
//        });
    }

    @Override
    public Observable<Progress> loadDome(String domeFile) {
        return null;
//        return Observable.create(sb -> {
//            GWT.log("start loadDome");
//
//            this.loadModel(domeFile, ModelOption.FLOOR)
//                    .subscribe(v -> {
//                        this.mmdDome = v.loadedResource();
//                        sb.onNext(convertLoadingProgress(v));
//                    },
//                            sb::onError, sb::onComplete);
//        });
    }

    @Override
    public Observable<Progress> loadCamera(String cameraFile) {
        return null;
//        return Observable.create(lc -> {
//            GWT.log("start loadCamera");
//
//            MMDLoader.OnProgressCallback onProgress = xhr -> {
//                lc.onNext(Progress.builder()
//                        .resourceName(cameraFile)
//                        .loaded(xhr.loaded)
//                        .total(xhr.total)
//                        .build());
//            };
//
//            MMDLoader.OnErrorCallback onError = error -> {
//                lc.onError(new RuntimeException(error.message));
//            };
//
//            getLoader().loadVmds(new String[]{cameraFile}, obj -> {
//
//                vmdCamera = obj;
//                mmdHelper.setCamera(camera);
//                getLoader().pourVmdIntoCamera(camera, obj);
//                mmdHelper.setCameraAnimation(camera);
//
//                lc.onComplete();
//
//            }, onProgress, onError);
//        });
    }

    @Override
    public HTMLCanvasElement canvas() {
        return canvasElement;
    }

    private MMDLoader getLoader() {
        return loader;
    }

    public HTMLCanvasElement getCanvasElement() {
        return canvasElement;
    }

    public HTMLElement getStatDomElement() {
        return stats.domElement;
    }

    private void init() {
        // Canvas creation
        canvasElement = (HTMLCanvasElement) DomGlobal.document.createElement("canvas");
        canvasElement.id = "glCanvas";

        // Stats
        stats = new Stats();
        stats.showPanel(0);
        stats.domElement.style.position = "absolute";
        stats.domElement.style.top = "";

        // Scene
        scene = new Scene();
        scene.setBackgroundColor(new Color());

        // Camera
        int width = this.canvasWidth;
        int height = this.canvasHeight;

        camera = new PerspectiveCamera(45, (float) width / (float) height, 1, 2000);
        controls = new OrbitControls(camera);
        camera.position.y = 20;
        camera.position.z = 30;
        controls.update();

        // Stage floor
//        Mesh ground = new Mesh(
//                new PlaneBufferGeometry(100, 100),
//                MeshPhongMaterial.builder().color(Color.valueOf(0xdddddd)).build()
//        );
//
//        ground.rotation.x = -90 * Math.PI / 180;
//        ground.position.y = -10;
//        ground.receiveShadow = true;
//        scene.add(ground);
        // Lighting
        AmbientLight ambientLight = new AmbientLight(Color.valueOf(0x666666));

        DirectionalLight light1 = new DirectionalLight(Color.valueOf(0x887766));
        light1.position.set(-15, 15, 15);
//        DirectionalLight light2 = new DirectionalLight(Color.valueOf(0x887766), 0.5);
//        light2.position.set(50, 15, 30);

        scene.add(ambientLight, light1);

        // Renderer
        renderer = WebGLRenderer.builder()
                .canvas(canvasElement)
                .antialias(true)
                .build();

        renderer.setPixelRatio(Window.getDevicePixelRatio());
        renderer.setSize(width, height);

        // Helper
        mmdHelper = new MMDHelper();

        // Effect
        effect = new OutlineEffect(renderer);

        // Shadow parameters
        renderer.shadowMap.enabled = true;
        light1.castShadow = true;
//        light1.shadow.mapSize.x = 1024;
//        light1.shadow.mapSize.y = 1024;
//        light1.shadow.getCamera().
        // Model specific Shadow parameters
//        renderer.shadowMap.renderSingleSided = false;
//        renderer.shadowMap.renderReverseSided = false;
//        light1.shadow.bias = -0.001;

        // Clock
        clock = new Clock();
    }

    public Observable<Float> load(String modelFile, String[] vmdFiles) {
        return Observable.create(observer -> {

            MMDLoader loader = new MMDLoader();

            MMDLoader.OnProgressCallback onProgress = xhr -> {
                observer.onNext((float) xhr.loaded / (float) xhr.total * 100);
            };

            MMDLoader.OnErrorCallback onError = error -> {
                observer.onError(new RuntimeException(error.message));
            };

            MMDLoader.OnModelLoadCallback onLoaded = obj -> {
                mmdCharacter = obj;
                mmdCharacter.position.y = -10;
                mmdCharacter.castShadow = true;
//                mmdModel.receiveShadow = true;

                scene.add(mmdCharacter);

                mmdHelper.add(mmdCharacter);
                mmdHelper.setAnimation(mmdCharacter);
                mmdHelper.setPhysics(mmdCharacter);

                MMDHelper.AnimationParam param = new MMDHelper.AnimationParam(2.0);
                mmdHelper.unifyAnimationDuration(param);

                observer.onComplete();
            };

            loader.load(modelFile, vmdFiles, onLoaded, onProgress, onError);
        });
    }

    private void animate() {
        callback = () -> {
            if (pause) {
                return;
            }
            Window.requestAnimationFrame(callback);

            stats.begin();
            render();
            stats.end();
        };

        Window.requestAnimationFrame(callback);
    }

    private void render() {
        mmdHelper.animate(clock.getDelta());

        effect.render(scene, camera);
    }

    public void resize(int width, int height) {
        this.canvasWidth = width;
        this.canvasHeight = height;

        camera.aspect = (float) width / (float) height;
        camera.updateProjectionMatrix();

        renderer.setSize(width, height);
    }

    public Scene getScene() {
        return scene;
    }

    @Override
    public void pause() {
        pause = true;
    }

    @Override
    public void play() {
        pause = false;

        MMDHelper.AnimationParam param = new MMDHelper.AnimationParam(2.0);
        mmdHelper.unifyAnimationDuration(param);

        animate();
    }

    @Override
    public void reset() {
        clock.stop();
    }

}
